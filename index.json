[{"content":"一名普通打工人，关注云原生相关的知识。\n","permalink":"https://jary-287.github.io/cloudnative.github.io/about/","summary":"一名普通打工人，关注云原生相关的知识。","title":"About"},{"content":" GitLab CI 入门 一、概述 1.组件 gitlab CI/CD gitlab的功能 gitlab Runner gitlab CICD的执行者 .gitlab-ci.yml 流水线描述文件，描述流水线执行的步骤 2.工作流程 将代码提交到git存储库\n在根目录中创建ci文件.gitlab-ci.yml,并在文件中指定各阶段操作\ngitlab监测到该文件并使用gitlab runner运行脚本\n脚本被分组成为作业，共同构成了一个管道\n3.jenkins VS gitlab CI jenkins 编译服务与代码库分离，耦合度低 插件丰富，支持语言多，但插件维护难 统一的web界面 体量大 权限管理难 gitlab CI 轻量级，不需要复杂的安装手段 配置简单 实时构建日志清晰 没有统一管理界面 配置依赖代码库，耦合度高 权限管理方便 二、gitlab 安装 1.gitlab 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 # 使用清华源安装https://mirrors.tuna.tsinghua.edu.cn/help/gitlab-ce/，不然下载到死 # curl https://packages.gitlab.com/gpg.key 2\u0026gt; /dev/null | sudo apt-key add - \u0026amp;\u0026gt;/dev/null # 添加镜像仓库 echo deb https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/ubuntu focal main \u0026gt;\u0026gt; /etc/apt/sources.list.d/gitlab-ce.list # 更新并安装 ljw@server:~$ sudo apt-get update ljw@server:~$ sudo apt-get install gitlab-ce # 修改配置文件 ljw@server:~$ sudo cat /etc/gitlab/gitlab.rb | grep external_url | grep -v ^# external_url \u0026#39;http://mygitlab.com\u0026#39; # 域名访问 # 重新配置并启动 ljw@server:~$ sudo gitlab-ctl reconfigure ljw@server:~$ sudo gitlab-ctl start # 查看默认密码然后登陆 ljw@server:~$ sudo cat /etc/gitlab/initial_root_password # WARNING: This value is valid only in the following conditions # 1. If provided manually (either via `GITLAB_ROOT_PASSWORD` environment variable or via `gitlab_rails[\u0026#39;initial_root_password\u0026#39;]` setting in `gitlab.rb`, it was provided before database was seeded for the first time (usually, the first reconfigure run). # 2. Password hasn\u0026#39;t been changed manually, either via UI or via command line. # # If the password shown here doesn\u0026#39;t work, you must reset the admin password following https://docs.gitlab.com/ee/security/reset_user_password.html#reset-your-root-password. Password: Kkg82QhvKwvDbjTZ9ElwN7nuxe/MeNCkfG2V54weyaM= # NOTE: This file will be automatically deleted in the first reconfigure run after 24 hours. 三、runner 1.什么是runner runner是go语言编写的跨平台的gitlab执行作业的agent，用于持续集成和持续部署中的脚本任务 2.特点 同时运行多个作业 在本地/docker/k8s执行 连接到远程ssh服务器 自动加载 允许自定义作业环境 3.类型/状态 类型 sheard共享类型，全部可用 group项目组类型 specific特定项目类型，当前项目可用 状态 locked：锁定状态，无法运行作业 paused ：暂停状态，不会接受新的作业 4.安装 ubuntu安装 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 # gitlab runner管理界面展示了安装方法，照做即可 # Download the binary for your system sudo curl -L --output /usr/local/bin/gitlab-runner https://gitlab-runner-downloads.s3.amazonaws.com/latest/binaries/gitlab-runner-linux-amd64 # Give it permission to execute sudo chmod +x /usr/local/bin/gitlab-runner # Create a GitLab Runner user sudo useradd --comment \u0026#39;GitLab Runner\u0026#39; --create-home gitlab-runner --shell /bin/bash # Install and run as a service sudo gitlab-runner install --user=gitlab-runner --working-directory=/home/gitlab-runner sudo gitlab-runner start # 注册 sudo gitlab-runner register --url http://mygitlab.com/ --registration-token M1jkqBfpuuzAnH9s7aYE # 删除 ljw@server:/etc$ sudo gitlab-runner verify --delete -t 7cEPwExkwMdD5_bU7ECh -u http://mygitlab.com/ # 注册相同,注册一个shared类型的runner ERRO[0000] Docker executor: prebuilt image helpers will be loaded from /var/lib/gitlab-runner. Running in system-mode. Please enter the gitlab-ci coordinator URL (e.g. https://gitlab.com/): [http://mygitlab.com/]: Please enter the gitlab-ci token for this runner: [M1jkqBfpuuzAnH9s7aYE]: Please enter the gitlab-ci description for this runner: [server]: Please enter the gitlab-ci tags for this runner (comma separated): implement Registering runner... succeeded runner=M1jkqBfp Please enter the executor: ssh, virtualbox, docker+machine, docker-ssh+machine, docker-ssh, parallels, kubernetes, docker, shell: shell Runner registered successfully. Feel free to start it, but if it\u0026#39;s running already the config should be automatically reloaded! docker安装 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 # 创建配置文件挂在目录 ljw@server:~$ mkdir gitlab_runner_config # 启动容器 ljw@server:~$ sudo docker run -d --name gitlab-runner --restart always -v /var/run/docker.so^C:/var/run/docker.sock -v /home/ljw/gitlab_runner_config/:/etc/gitlab-runner gitlab/gitlab-runner:latest [sudo] password for ljw: Unable to find image \u0026#39;gitlab/gitlab-runner:latest\u0026#39; locally latest: Pulling from gitlab/gitlab-runner 846c0b181fff: Pull complete f05423af2dfd: Pull complete d92eb7aeb475: Pull complete Digest: sha256:15a3945030802e20d24326aef1e60b69478336842db88069303ddfdfe9cebf9a Status: Downloaded newer image for gitlab/gitlab-runner:latest 6125256c41ce4dc86f54aac997b50a633b94a0c94209740a3dc3be9e4e0983b7 ljw@server:~$ sudo docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 6125256c41ce gitlab/gitlab-runner:latest \u0026#34;/usr/bin/dumb-init …\u0026#34; 19 seconds ago Up 17 seconds gitlab-runner # 新建一个测试项目，test # 略 # 注册一个特定项目runner，为test,确保容器能解析到mygitlab.com ljw@server:~$ sudo docker exec -it gitlab-runner /bin/bash root@6125256c41ce:/# gitlab-runner register --url http://mygitlab.com/ --registration-token GR1348941sgKMG1cURqipSf8s7u7M Runtime platform arch=amd64 os=linux pid=56 revision=6d480948 version=15.7.1 Running in system-mode. Enter the GitLab instance URL (for example, https://gitlab.com/): [http://mygitlab.com/]: Enter the registration token: [GR1348941sgKMG1cURqipSf8s7u7M]: Enter a description for the runner: [6125256c41ce]: Enter tags for the runner (comma-separated): Enter optional maintenance note for the runner: WARNING: Support for registration tokens and runner parameters in the \u0026#39;register\u0026#39; command has been deprecated in GitLab Runner 15.6 and will be replaced with support for authentication tokens. For more information, see https://gitlab.com/gitlab-org/gitlab/-/issues/380872 Registering runner... succeeded runner=GR1348941sgKMG1cU Enter an executor: kubernetes, custom, docker, parallels, shell, ssh, docker+machine, instance, docker-ssh, virtualbox, docker-ssh+machine: shell Runner registered successfully. Feel free to start it, but if it\u0026#39;s running already the config should be automatically reloaded! Configuration (with the authentication token) was saved in \u0026#34;/etc/gitlab-runner/config.toml\u0026#34; 四、CICD流水线 1.基本使用 创建项目test ​\t项目根目录下创建流水线文件.gitlab-ci.yml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 stages: # List of stages for jobs, and their order of execution - build - test - deploy build-job: # This job runs in the build stage, which runs first. stage: build script: - echo \u0026#34;Compiling the code...\u0026#34; - echo \u0026#34;Compile complete.\u0026#34; unit-test-job: # This job runs in the test stage. stage: test # It only starts when the job in the build stage completes successfully. script: - echo \u0026#34;Running unit tests... This will take about 60 seconds.\u0026#34; - sleep 5 - echo \u0026#34;Code coverage is 90%\u0026#34; lint-test-job: # This job also runs in the test stage. stage: test # It can run at the same time as unit-test-job (in parallel). script: - echo \u0026#34;Linting code... This will take about 10 seconds.\u0026#34; - sleep 10 - echo \u0026#34;No lint issues found.\u0026#34; deploy-job: # This job runs in the deploy stage. stage: deploy # It only runs when *both* jobs in the test stage complete successfully. environment: production script: - echo \u0026#34;Deploying application...\u0026#34; - echo \u0026#34;Application successfully deployed.\u0026#34; 每一次修改都会触发流水线\n可点击某一次流水线查看执行详情\npipeline文件中定义了三个阶段，build，test，deploy，可分别查看\n​\t2.流水线语法检测 使用CI lint 检查pipeline文件语法是否正确，然后再修改仓库文件 3.pipeline语法 关键字概览 关键词 作用 job pipeline文件中由多个作业组成，每个作业必须有一个script，名字必须唯一 script 指定具体的操作，现在是shell语句 before_script 作业运行之前要做的操作，如果是全局的，每个作业都会执行 after_script 作业运行之后要做的操作，如果是全局的，每个作业都会执行 stages 控制stage的顺序，一个stage可能执行多个作业 stage 指定当前是哪个stage，两个关键字：.pre为第一个运行，.post为最后运行 variables 定义变量 tags 指定runner allow_failure 允许失败，默认值为false when 控制作业执行条件 retry 重试次数 timeout 超时时间 parallel 并行作业实例数，2\u0026lt;x\u0026lt;50，创建n个运行同一作业 only 限制哪些分支和tag会被job执行 except 限制哪些分支和tag不会被job执行 rules 构建规则，按顺序匹配为作业提供属性 workflow 适用于整个管道是否创建 cache 存储编译时所需要的运行时依赖项，指定项目空间中需要在job之间缓存的文件/目录，可全局定义或局部定义 artifacts 制品，作业成功或失败时附加到作业的文件或目录列表，作业完成后发送到gitlab\u0026lt;br / dependencies 使用制品 needs 阶段并行，适用于执行无序的作业 include 引用配置 extends 继承作业配置，从模版中继承，新定义的则不继承，其他的全部继承 trigger 触发器，触发别的管道 image 指定docker excutor的镜像 services 依赖镜像服务 inherit 是否使用定义的全局变量 environment 指定发布环境 基本关键字使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 # 编写案例 before_script: # 执行前动作 - echo \u0026#34;this is global before script\u0026#34; variables: # 变量定义 Version: \u0026#34;16.2\u0026#34; stages: # 定义阶段运行顺序 - build - test - deploy - clean build: # job名字为build stage: build script: - echo \u0026#34;start build\u0026#34; - sleep 5 - echo \u0026#34;build success\u0026#34; after_script: - echo \u0026#34;this is after build script\u0026#34; test: stage: test script: - echo \u0026#34;this is test $Version\u0026#34; deploy: stage: deploy script: - echo \u0026#34;deploying\u0026#34; clean: stage: .post script: - echo \u0026#34;clean environment\u0026#34; 更新pipeline文件观察执行结果 tags、allow_failure、when、retry、timeout、parallel 关键字 作用 tags 指定runner allow_failure 允许失败，默认值为false when 控制作业执行；\non_success:前面阶段成功才执行，\non_failure:前面阶段出现失败时执行\nalways:总是执行\nmanual:手动\ndelayed:延迟执行 retry 重试次数 timeout 超时时间 parallel 并行作业实例数，2\u0026lt;x\u0026lt;50，创建n个运行同一作业 编写测试案例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 # 编写案例 variables: # 变量定义 Version: \u0026#34;16.2\u0026#34; stages: # 定义阶段运行顺序 - build - test - deploy - clean build: # job名字为build stage: build script: - echo \u0026#34;start build\u0026#34; - sleep 5 - eho \u0026#34;build success\u0026#34; after_script: - echo \u0026#34;this is after build script\u0026#34; allow_failure: true retry: 2 test: stage: test script: - eho \u0026#34;this is test $Version\u0026#34; deploy: stage: deploy tags: - implement script: - echo \u0026#34;deploying\u0026#34; timeout: 1 minute when: on_failure clean: stage: .post script: - echo \u0026#34;clean environment\u0026#34; parallel: 2 when: on_failure 运行结果： build三次都失败但是忽略， test失败， deploy指定shared runner， deploy和clean都是on_failure执行，因此会执行 only,except,rules,workflow 关键字 作用 only 限制哪些分支和tag会被job执行 except 限制哪些分支和tag不会被job执行 rules 构建规则，按顺序匹配为作业提供属性\nif（如果条件匹配）\nchanges（如果条件发生改变）\nexists（指定文件存在） workflow 适用于整个管道是否创建 案例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 # 编写案例 variables: # 变量定义 Version: \u0026#34;16.2\u0026#34; Domain: a.com workflow: # a.com则创建pipeline rules: - if: $Domain == \u0026#34;a.com\u0026#34; when: always - when: never stages: # 定义阶段运行顺序 - build - test - deploy - clean build: # job名字为build stage: build script: - echo \u0026#34;start build\u0026#34; - sleep 5 - echo \u0026#34;build success\u0026#34; after_script: - echo \u0026#34;this is after build script\u0026#34; allow_failure: true retry: 2 test: # main分支才执行test stage: test script: - echo \u0026#34;this is test $Version\u0026#34; only: - main deploy: # develop分支不执行这一步 stage: deploy tags: - implement script: - echo \u0026#34;deploying\u0026#34; timeout: 1 minute except: - develop clean: stage: .post script: - echo \u0026#34;clean environment\u0026#34; parallel: 2 rules: # 存在jenkinsFile才会有这一阶段 - exists: - jenkinsFile 执行结果 cache,artifacts,dependencies 关键字 作用 cache 存储编译时所需要的运行时依赖项，指定项目空间中需要在job之间缓存的文件/目录，可全局定义或局部定义\npaths：指定缓存目录/文件\nkey:标识缓存\nkey:files:文件变化自动创建缓存，files最多指定两个文件\nprefix:允许给定prefix的值与指定文件生成密钥组合\npolicy:缓存策略，默认在开始时下载文件，在结束时上传文件，设置为pull跳过下载步骤，设置为push跳过上传步骤 artifacts 制品，作业成功或失败时附加到作业的文件或目录列表，作业完成后发送到gitlab\npaths：收集文件或者目录\nexpose_as:展示在ui的名称\nname:制品名称,可以使用变量，如$CI_JOB_NAME\nwhen:制品创建条件\nexpire_in:制品保留时间\nreports:junit:单元测试报告\nreports:cobertura:覆盖率 dependencies 使用制品 cache默认缓存策略\n缓存案例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 # 编写案例 variables: # 变量定义 Version: \u0026#34;16.2\u0026#34; Domain: a.com workflow: rules: - if: $Domain == \u0026#34;a.com\u0026#34; when: always - when: never cache: paths: - target/ # 缓存target目录 stages: # 定义阶段运行顺序 - build - test - deploy - clean build: # job名字为build stage: build tags: - deploy - implement script: - echo \u0026#34;start build\u0026#34; - ls - id - mkdir target - echo \u0026#34;build success\u0026#34; after_script: - echo \u0026#34;this is after build script\u0026#34; allow_failure: true retry: 2 test: stage: test tags: - implement - deploy script: - echo \u0026#34;run test $Version\u0026#34; - echo test \u0026gt;\u0026gt; target/a.txt only: - main deploy: stage: deploy tags: - deploy script: - echo \u0026#34;deploying\u0026#34; - cat target/a.txt - echo \u0026#34;deploy success\u0026#34; clean: stage: .post script: - echo \u0026#34;clean environment\u0026#34; parallel: 2 rules: - exists: - jenkinsFile 执行结果分析\ncache默认存放在家目录\nbuild阶段：下载上一次的缓存，执行结束后生成缓存，都存在本地家目录 test阶段：检出分支，删掉本地的target，加载缓存，执行完保存缓存\ndeploy阶段：已经保存的上次的缓存可以直接查看内容\n制品案例\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 # 编写案例 variables: # 变量定义 Version: \u0026#34;16.2\u0026#34; Domain: a.com workflow: rules: - if: $Domain == \u0026#34;a.com\u0026#34; when: always - when: never stages: # 定义阶段运行顺序 - build - test - deploy - clean build: # job名字为build stage: build tags: - deploy script: - echo \u0026#34;start build\u0026#34; - ls - id - mkdir target - echo \u0026#34;build success\u0026#34; after_script: - echo \u0026#34;this is after build script\u0026#34; allow_failure: true retry: 2 artifacts: paths: - target/ test: stage: test tags: - deploy script: - echo \u0026#34;run test $Version\u0026#34; - echo test \u0026gt;\u0026gt; target/a.txt only: - main artifacts: paths: - target/ expose_as: target_file name: a.txt when: on_success dependencies: - build deploy: stage: deploy dependencies: - test script: - echo \u0026#34;deploying\u0026#34; - cat target/a.txt - echo \u0026#34;deploy success\u0026#34; clean: stage: .post script: - echo \u0026#34;clean environment\u0026#34; parallel: 2 rules: - exists: - jenkinsFile 在job中可以看到上传制品，并且可以直接浏览下载\nneeds 阶段并行，适用于执行无序的作业 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 # 原始效果，AB两个build都结束才可以执行AB两个test # needs实现A执行完就可以执行A的test，节省时间 # 编写案例 variables: # 变量定义 Version: \u0026#34;16.2\u0026#34; Domain: a.com workflow: rules: - if: $Domain == \u0026#34;a.com\u0026#34; when: always - when: never stages: # 定义阶段运行顺序 - build - test - deploy - clean build A: # job名字为build stage: build tags: - deploy script: - echo \u0026#34;start build\u0026#34; - ls - id - mkdir target - echo \u0026#34;build success\u0026#34; - sleep 10 after_script: - echo \u0026#34;this is after build script\u0026#34; allow_failure: true retry: 2 artifacts: paths: - target/ build B: # job名字为build stage: build tags: - deploy script: - echo \u0026#34;start build\u0026#34; - ls - id - mkdir target - echo \u0026#34;build success\u0026#34; - sleep 4 after_script: - echo \u0026#34;this is after build script\u0026#34; allow_failure: true retry: 2 artifacts: paths: - target/ test A: stage: test tags: - deploy script: - echo \u0026#34;run test $Version\u0026#34; - echo test \u0026gt;\u0026gt; target/a.txt only: - main needs: - job: build A artifacts: true test B: stage: test tags: - deploy script: - echo \u0026#34;run test $Version\u0026#34; - echo test \u0026gt;\u0026gt; target/a.txt only: - main needs: - job: build B artifacts: true include引用\nlocal：引用同一存储库中的文件，使用相对于根目录的完整路径进行引用 file:引用其他项目配置 template：引用官方模版 remote：远程文件地址 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 # 创建CI文件夹，存放引用文件 ci/local.yml deploy: stage: deploy script: - echo deploy # 编写案例 variables: # 变量定义 Version: \u0026#34;16.2\u0026#34; Domain: a.com workflow: rules: - if: $Domain == \u0026#34;a.com\u0026#34; when: always - when: never include: # local: ci/local.yml # remote 要能获取到 # remote: \u0026#39;http://mygitlab.com/gitlab-instance-77485aca/test/-/raw/main/ci/local.yml\u0026#39; - project: \u0026#39;gitlab-instance-77485aca/test\u0026#39; file: ci/local.yml ref: main # template: Auto-DevOps.gitlab-ci.yml stages: # 定义阶段运行顺序 - build - test - deploy build A: # job名字为build stage: build tags: - deploy script: - echo \u0026#34;start build\u0026#34; - ls - id - mkdir target - echo \u0026#34;build success\u0026#34; test A: stage: test tags: - deploy script: - echo \u0026#34;run test $Version\u0026#34; extends：继承作业配置，从模版中继承，新定义的则不继承，其他的全部继承\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 # 案例：使用extends继承了属性，test阶段直接被跳过，因为前一个任务执行失败才会执行 # 编写案例 variables: # 变量定义 Version: \u0026#34;16.2\u0026#34; Domain: a.com workflow: rules: - if: $Domain == \u0026#34;a.com\u0026#34; when: always - when: never stages: # 定义阶段运行顺序 - build - test common: script: - ehco this is script when: on_failure build A: # job名字为build stage: build tags: - deploy script: - echo \u0026#34;start build\u0026#34; - ls - id - mkdir target - echo \u0026#34;build success\u0026#34; test A: stage: test extends: common tags: - deploy script: - echo \u0026#34;run test $Version\u0026#34; trigger：触发器\n从trigger定义创建的作业启动时将创建一个下游管道 允许创建多项目管道和子管道 trigger与when：manual一起时会出错 多项目管道：一个项目中的管道可以触发其他项目中的管道（微服务架构） 父子管道：在项目中触发一组同时运行的管道，不受父管道进度限制 多项目管道实例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 # 创建项目test2并设置pipeline stages: - deploy deploy: stage: deploy script: - echo \u0026#34;test2 deploying\u0026#34; # 在test中使用trigger触发test2的管道 # 编写案例 variables: # 变量定义 Version: \u0026#34;16.2\u0026#34; Domain: a.com stages: # 定义阶段运行顺序 - build - deploy build A: # job名字为build stage: build script: - echo \u0026#34;start build\u0026#34; - echo \u0026#34;build success\u0026#34; deploy: stage: deploy trigger: project: gitlab-instance-77485aca/test2 branch: main strategy: depend 父子项目管道实例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # 编写案例 variables: # 变量定义 Version: \u0026#34;16.2\u0026#34; Domain: a.com stages: # 定义阶段运行顺序 - build - deploy build A: # job名字为build stage: build script: - echo \u0026#34;start build\u0026#34; - echo \u0026#34;build success\u0026#34; deploy: stage: deploy trigger: include: ci/local.yml # 创建子管道 strategy: depend # 子管道执行完父管道才算执行结束，继续下面的执行 image/services image：docker执行器需要制定镜像，所有的操作都会在容器中执行，job中指定镜像优先级高于runner镜像 service:依赖服务，后面构建过程中可以直接使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 # 创建docker执行器，指定镜像为alpine:latest # 设置镜像拉取策略,因为我使用的是主机名解析，要确保容器也能访问到gitlab，因此我将宿主机的hosts文件挂在进容器 ljw@server:~$ sudo grep -C2 pull_policy /etc/gitlab-runner/config.toml [runners.cache.azure] [runners.docker] pull_policy = \u0026#34;if-not-present\u0026#34; tls_verify = false image = \u0026#34;alpine:latest\u0026#34; volumes = [\u0026#34;/etc/hosts:/etc/hosts:rw\u0026#34;,\u0026#34;/cache\u0026#34;] # 创建测试pipeline variables: # 变量定义 Version: \u0026#34;16.2\u0026#34; Domain: a.com stages: # 定义阶段运行顺序 - build services: - name: redis:latest alias: myredis build A: # job名字为build stage: build tags: - docker script: - echo \u0026#34;start build\u0026#34; - echo \u0026#34;build success\u0026#34; environment 指定作业发布，方便ui统一管理环境的发布记录以及重新发布等 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 variables: # 变量定义 Version: \u0026#34;16.2\u0026#34; Domain: a.com stages: # 定义阶段运行顺序 - build build A: # job名字为build stage: build tags: - docker script: - echo \u0026#34;start build\u0026#34; - echo \u0026#34;build success\u0026#34; environment: name: production # 指明生产环境 url: http:www.baidu.com # 为生产环境指定一个url inherit 是否使用定义的全局变量 4.模版库规划 1.创建一个git仓库ci存放模版 2.templates目录存放pipeline模版 3.jobs目录存放job模版 五、工具链继承 1.Maven集成 安装maven环境，maven是java项目的构建打包工具 1 2 3 4 5 6 7 # 安装不用多说 ljw@server:~$ mvn -v Apache Maven 3.6.3 Maven home: /usr/share/maven Java version: 1.8.0_341, vendor: Oracle Corporation, runtime: /home/ljw/tools/jdk1.8.0_341/jre Default locale: en_US, platform encoding: UTF-8 OS name: \u0026#34;linux\u0026#34;, version: \u0026#34;5.4.0-136-generic\u0026#34;, arch: \u0026#34;amd64\u0026#34;, family: \u0026#34;unix\u0026#34; 创建build作业模版 1 2 3 4 5 6 7 8 # jobs目录下新建build.yml .build: # 加.作为模版为下面继承 stage: build tags: - build script: - $build_shell - ls 创建pipeline模版 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 在templates目录下新建java-common.yml include: project: devops/ci ref: main file: jobs/build.yml variables: build_shell: \u0026#39;mvn clean package -DskipTests\u0026#39; cache_dir: target cache: paths: - $cache_dir build: stage: build extends: .build 创建一个maven项目 1 2 # 直接import gitee中的jtimer项目 # 增加pipeline文件 进行扩展，在jobs加入test.yml 1 2 3 4 5 6 7 8 9 10 11 .test: stage: test tags: - build script: - $test_shell artifacts: paths: - $result reports: junit: target/surefire-reports/TEST-*.yml 将test加到java的pipeline模版中 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 include: - project: devops/ci ref: main file: jobs/build.yml - project: devops/ci ref: main file: jobs/test.yml variables: build_shell: \u0026#39;mvn clean package -DskipTests\u0026#39; test_shell: \u0026#39;mvn test \u0026#39; cache_dir: target result: target/ cache: paths: - $cache_dir stages: - build - test build: stage: build extends: .build test: stage: test extends: .test 更多的阶段都类似 2.Npm集成 创建一个npm项目,直接找一个开源项目import，我使用若依的前端‘\n在ci项目template目录下创建npm-common.yml用作npm模版文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 include: - project: devops/ci ref: main file: jobs/build.yml stages: - build variables: build_shell: \u0026#34;npm run build:prod\u0026#34; # package.json中定义了构建脚本 build: stage: build before_script: - npm install # npm项目需要安装依赖 extends: .build 在项目下新建pipeline文件 1 2 3 4 5 6 7 include: - project: devops/ci ref: main file: templates/npm-common.yml image: name: node:16 构建成功 需要其他操作再进行扩展即可 3.集成制品库 直接使用docker安装artifactory进行集成 1 2 sudo docker pull releases-docker.jfrog.io/jfrog/artifactory-oss:latest # 参考https://www.jfrog.com/confluence/display/JFROG/Installing+Artifactory#114759846aa77ee5734e34d7b8d6fba728e7f646f 进行安装 artifactory是一个制品仓库，创建一个cidevops的仓库\n使用账号密码/apikey/accesskey等方式可以进行接口操作，下面演示使用账号密码进行制品的上传\n上传时可使用多级目录记录制品的应用，版本，分支，等等信息\n1 2 3 4 5 6 7 8 # 在jobs中加入上传制品的步骤，此时jobs目录下新建upload.yml内容为 .deploy_artifact: stage: upload tags: - build script: - curl -u$ArtifactoryUser:$ArtifactoryPass -X PUT \u0026#34;$ArtifactoryUrl/$ArtifactoryName/$TargetFilePath/$TargetFileName\u0026#34; -T $ArtifactoryPath 对于一些隐私数据可以在项目-\u0026gt;设置-\u0026gt;CICD中设置变量,这里设置Artifactory的账号密码 在java的模版中加入上传制品步骤 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 include: - project: devops/ci ref: main file: jobs/build.yml - project: devops/ci ref: main file: jobs/test.yml - project: devops/ci ref: main file: jobs/upload.yml variables: build_shell: \u0026#39;mvn clean package -DskipTests\u0026#39; test_shell: \u0026#39;mvn test \u0026#39; cache_dir: target result: target ArtifactoryPath: target/*.jar # 上传制品库 ArtifactoryUrl: http://192.168.0.14:8081/artifactory ArtifactoryName: cidevops TargetFilePath: ${CI_PROJECT_NAMESPACE}/${CI_PROJECT_NAME}/${CI_COMMIT_REF_NAME}-${CI_COMMIT_SHA}-${CI_PIPELINE_NAME} TargetFileName: ${CI_PROJECT_NAME}-${CI_COMMIT_REF_NAME}-${CI_COMMIT_SHA}-${CI_PIPELINE_NAME}.jar cache: paths: - $cache_dir stages: - build - test - upload build: stage: build extends: .build test: stage: test extends: .test deploy_artifact: stage: upload extends: .deploy_artifact 制品上传成功，目录结构为组/项目/分支等信息 download可以新建job\n1 2 3 4 5 6 7 # down_artifact.yml .down_artifact: stage: deploy tags: - build script: - curl -u{ArtifactoryUser}:${ArtifactoryPass} -O \u0026#34;${ArtifactoryUrl}${ArtifactoryName}/${TargetFilePath}/${TargetFileName}\u0026#34; 4.镜像仓库集成 通过DockerFile进行打包构建，再通过接口上传到镜像仓库 1 2 3 4 5 6 7 8 9 10 11 # 源代码中上传DockerFile # 在upload.yml中 .docker-build: stage: build tags: - docker-build # runner上必须有docker，最好用shell executor script: - docker login -u ${CI_REGISTRY_USER} -p ${CI_REGISTRY_PASS} ${CI_REGISTRY} - dodcker build -t ${IMAGE_NAME} -f ${DOCKERFILE_PATH} - docker push ${IMAGE_NAME} - docker rmi ${IMAGE_NAME} 此时的java-common.yml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 include: - project: devops/ci ref: main file: jobs/build.yml - project: devops/ci ref: main file: jobs/test.yml - project: devops/ci ref: main file: jobs/down_artifact.yml - project: devops/ci ref: main file: jobs/upload.yml variables: build_shell: \u0026#39;mvn clean package -DskipTests\u0026#39; test_shell: \u0026#39;mvn test \u0026#39; cache_dir: target result: target ArtifactoryPath: target/*.jar # 上传制品库 ArtifactoryUrl: http://192.168.0.14:8081/artifactory ArtifactoryName: cidevops TargetFilePath: ${CI_PROJECT_NAMESPACE}/${CI_PROJECT_NAME}/${CI_COMMIT_REF_NAME}-${CI_COMMIT_SHA}-${CI_PIPELINE_NAME} TargetFileName: ${CI_PROJECT_NAME}-${CI_COMMIT_REF_NAME}-${CI_COMMIT_SHA}-${CI_PIPELINE_NAME}.jar # docker配置 DOCKERFILE_PATH: \u0026#34;./Dockerfile\u0026#34; CI_REGISTRY: ccr.ccs.tencentyun.com REGISTRY_PATH: idevops CI_REGISTRY_USER: 100018599267 CI_REGISTRY_PASS: ljw00000 VERSION: 1.0. # 这里只是实验，可以使用变量 IMAGE_NAME: ${CI_REGISTRY}/${REGISTRY_PATH}/${CI_PROJECT_NAME}:${VERSION} cache: paths: - $cache_dir stages: - build - test - upload - down build: stage: build extends: .build test: stage: test extends: .test allow_failure: true down: stage: down extends: .down_artifact deploy_artifact: stage: upload extends: .deploy_artifact upload_docker: stage: upload extends: .docker-build 此处使用腾讯云个人镜像仓库 简单编写Dockerfile 1 2 3 FROM openjdk:8-alpine ADD target/*.jar /app.jar ENTRYPOINT [\u0026#34;java\u0026#34;,\u0026#34;-jar\u0026#34;,\u0026#34;/app.jar\u0026#34;] 设置分布式缓存，目前阶段都是docker执行器，docker build在shell执行器比较方便，但是多个runner需要设置分布式缓存,我使用七牛云的对象存储，支持s3接口 1 2 3 4 5 6 7 8 9 10 11 12 # /etc/gitlab-runner/config.toml缓存部分配置 [runners.cache] Type = \u0026#34;s3\u0026#34; Path = \u0026#34;gitlab-ci-cache\u0026#34; Shared = true MaxUploadedArchiveSize = 0 [runners.cache.s3] ServerAddress = \u0026#34;s3-cn-east-1.qiniucs.com\u0026#34; # 地址 AccessKey = \u0026#34;x x x x\u0026#34; SecretKey = \u0026#34;xxxxx\u0026#34; BucketName = \u0026#34;ljw-devops\u0026#34; Insecure = true 测试pipeline 5.jmeter自动化测试集成 使用ant+jmeter自动化测试 开启gitlab pages功能收集测试报告进行展示 在项目结束集成后触发这个下游项目进行自动化测试 ​\t这块不熟，不会写测试文件，后续补充\n6.SonarQube代码扫描集成","permalink":"https://jary-287.github.io/cloudnative.github.io/posts/note/gitlab/","summary":"","title":"GitLab CI 入门"},{"content":"","permalink":"https://jary-287.github.io/cloudnative.github.io/posts/think/demo/","summary":"","title":"这是一个demo文章"}]